package br.com.cidacastello.java.sao.backup;

import java.util.Random;

/**
 * CLASSE RESPONSÁVEL PELA COLÔNIA
 * 
 * @author Guilherme França
 * @author Cida
 */
public class Colony {
    
    Ant ant;

    private double q;  // = 0.1  'representa abrangencia das formigas, qto + proximo 1, maior abrangencia na busca das formigas
    private double chi;  // '= 0.9999 'representa a taxa de evaporacao de feromonio ACO padrao
    private int condicaoDeParada; // '= 100
    /* Matriz T com K soluções aleatórias ======================= '
     *matrizT(k,6) => 6 colunas para as 6 variáveis peca[].
     *matriz para pecaPE e pecaMC //
     |     0   |    1     |    2    |    3    |    4    |    5    |
     | qtdePE1 | qtdePE2  | qtdePE3 | qtdePE4 | qtdePE5 | qtdePE6 |
     */

    /*dimensão menos 1 */
    private int K;  //'= 500 - 1 'representa o número de soluções aleatórias
    private int m;  // '= 20 - 1     '=> a set of m solutions is generated by the ants and added to those in matrizT
    private double[] vetorW; //           tamanho k  'Vetor que armazena os pesos de cada solução da tabela / estrutura
    private double[] vetorProbabilidade;  // tamanho k   'vetor para armazenar o calculo das probabilidades
    private int quantidadeIteracoes;  // 'quantidade de iteracoes do algoritmo

    /**
     * CALCULA O PESO
     * @param L ÍNDICE DA TABELA
     * @return O PESO
     */
    public double calcularPesoW(int L) {
        double peso;
        double auxE = Math.pow(L - 1, 2) / (2 * Math.pow(q, 2) * Math.pow(K, 2));
        double auxPeso = q * K * Math.sqrt(2 * Math.PI);
        peso = 1 / auxPeso * Math.pow(Math.E, -auxE);
        return peso;
    }
    
    /**
     * CALCULA A PROBABILIDADE
     * 
     * @param pesoWl PESO
     * @param totalPesos TOTAL DOS PESOS
     * @return 
     */
    public double calculaProbabilidade(double pesoWl, double totalPesos) {
        return (pesoWl / totalPesos);
    }

    public int roleta(double limite) {

        double aux = 0;
        int i;

        for (i = 0; i <= K; i++) {
            if (aux <= limite) {
                //aux = aux + stAtual(i).probabilidade
            } else {
                return i;
            }
        }

        if (i > K) {
            i = K;
        }

        return i;
    }

    public double somatorioPesos() {
        double soma = 0;

        for (int i = 0; i <= K; i++) {
            //soma = soma + stAtual(i).pesoW
        }
        return soma;
    }

    public void iniciaSolucaoT() {
        int i;
        //'gera os valores aleatórios para cada parâmetro da Minimo Custo
        //'primeira tabela 
        for (i = 0; i <= K; i++) {
            // 'gera os valores para SH
            //stAtual(i).Sh = aleatorio((stInicial.Sh * (1 - stPercParametros.Sh / 100)), (stInicial.Sh * (1 + stPercParametros.Sh / 100)))  'matrizT(i, 0)
            //  'gera os valores para CM
            //  stAtual(i).Cm = aleatorio((stInicial.Cm * (1 - stPercParametros.Cm / 100)), (stInicial.Cm * (1 + stPercParametros.Cm / 100)))  'matrizT(i, 1)
            //  'gera os valores para KFT
            //  stAtual(i).Kft = aleatorio((stInicial.Kft * (1 - stPercParametros.Kft / 100)), (stInicial.Kft * (1 + stPercParametros.Kft / 100)))  'matrizT(i, 2)
            //   'gera os valores para TFT
            // stAtual(i).Tft = aleatorio((stInicial.Tft * (1 - stPercParametros.Tft / 100)), (stInicial.Tft * (1 + stPercParametros.Tft / 100)))  'matrizT(i, 3)
            //   'gera os valores para CTU
            //   stAtual(i).Ctu = aleatorio((stInicial.Ctu * (1 - stPercParametros.Ctu / 100)), (stInicial.Ctu * (1 + stPercParametros.Ctu / 100))) 'matrizT(i, 4)
            //   'gera os valores para SM
            //   stAtual(i).Sm = aleatorio((stInicial.Sm * (1 - stPercParametros.Sm / 100)), (stInicial.Sm * (1 + stPercParametros.Sm / 100)))  'matrizT(i, 5)
            //  'calcula as VC
            //  stAtual(i).Vcmc = calculaVcmc(stFixo.k, stAtual(i).Sh, stAtual(i).Sm, stFixo.x, stAtual(i).Kft, stAtual(i).Tft) 'matrizT(i, 6)
            //  stAtual(i).VcmcLim = calculaVcmcLim(stFixo.k, stAtual(i).Sh, stAtual(i).Sm, stFixo.x, stAtual(i).Kft)
            //   stAtual(i).VcmXp = calculaVcmXp(stFixo.k, stFixo.x, stAtual(i).Tft)
            //   'calcula a FO para cada linha
            //   stAtual(i).KpVcmc = calculaCustoTotalKp(stAtual(i).Sh, stAtual(i).Cm, stAtual(i).Kft, stAtual(i).Tft, stAtual(i).Ctu, stAtual(i).Sm, stAtual(i).Vcmc)  'matrizT(i, 7)
        }


        // 'calcula o total dos pesos
        double totalPesos;


        // 'chamar formigas para escolher uma solução probabilisticamente.
        //  'vejo se a probabilidade for < então aceito para a formiga
        //  'for para as formigas

        //    double limite  = aleatorio(0, somatorioPesos());  //valor do sorteio
        int indiceSolucaoEscolhida;
        //  ' Dim formiga(m) As Estado
        //  Dim auxiliar(K + m + 1) As Estado

        double escolhaSolucaoProbabilidade;



        quantidadeIteracoes = 1;

        while (quantidadeIteracoes < condicaoDeParada) {
            // 'ordena a estrutura 
            //  ordenacaoBubbleSortKpVcmc(stAtual)



            //   'calcula o peso 
            for (i = 0; i <= K; i++) {
                //  stAtual(i).pesoW = calculaPesoW(i)
            }

            //  totalPesos = somatorioPesos()

            //  'calcular a probabilidade

            for (i = 0; i <= K; i++) {
                // stAtual(i).probabilidade = calculaProbabilidade(stAtual(i).pesoW, totalPesos)
            }


            //  'chamar formigas para escolher uma solução probabilisticamente.
            //  'vejo se a probabilidade for < então aceito para a formiga
            //  'for para as formigas

            //  ' Dim auxFormigaDesvioPadrao As Estado  'contem o desvio padrao de todos os campos

            for (i = 0; i <= m; i++) {
                //     '   arquivoTexto.WriteLine("Formiga = " & i)
                //    'escolhe uma solucao aleatoria
                //    escolhaSolucaoProbabilidade = aleatorio_01()
                //   indiceSolucaoEscolhida = roleta(escolhaSolucaoProbabilidade)
                //  formiga(i).Sh = Gaussian(stAtual(indiceSolucaoEscolhida).Sh, stAtual(indiceSolucaoEscolhida).pesoW, "Sh", indiceSolucaoEscolhida)
                //  formiga(i).Cm = Gaussian(stAtual(indiceSolucaoEscolhida).Cm, stAtual(indiceSolucaoEscolhida).pesoW, "Cm", indiceSolucaoEscolhida)
                //   formiga(i).Ctu = Gaussian(stAtual(indiceSolucaoEscolhida).Ctu, stAtual(indiceSolucaoEscolhida).pesoW, "Ctu", indiceSolucaoEscolhida)
                //   formiga(i).Kft = Gaussian(stAtual(indiceSolucaoEscolhida).Kft, stAtual(indiceSolucaoEscolhida).pesoW, "Kft", indiceSolucaoEscolhida)
                //   formiga(i).Sm = Gaussian(stAtual(indiceSolucaoEscolhida).Sm, stAtual(indiceSolucaoEscolhida).pesoW, "Sm", indiceSolucaoEscolhida)
                //   formiga(i).Tft = Gaussian(stAtual(indiceSolucaoEscolhida).Tft, stAtual(indiceSolucaoEscolhida).pesoW, "Tft", indiceSolucaoEscolhida)
                //   formiga(i).Vcmc = calculaVcmc(stFixo.k, formiga(i).Sh, formiga(i).Sm, stFixo.x, formiga(i).Kft, formiga(i).Tft)
                //   formiga(i).VcmcLim = calculaVcmcLim(stFixo.k, formiga(i).Sh, formiga(i).Sm, stFixo.x, formiga(i).Kft)
                //   stAtual(i).VcmXp = calculaVcmXp(stFixo.k, stFixo.x, formiga(i).Tft)
                //    'calcula a FO para cada linha
                //    formiga(i).KpVcmc = calculaCustoTotalKp(formiga(i).Sh, formiga(i).Cm, formiga(i).Kft, formiga(i).Tft, formiga(i).Ctu, formiga(i).Sm, formiga(i).Vcmc)
            }

            //  ordenacaoBubbleSorEstrutura(formiga)

            for (i = 0; i <= K; i++) {
                //   auxiliar(i) = stAtual(i)
            }

            for (i = 0; i <= m; i++) {
                //  auxiliar(K + i + 1) = formiga(i)
            }

            // ordenacaoBubbleSorEstrutura(auxiliar)

            // for (i = 0; i <  auxiliar.Length ; i++){
            //     arquivoAuxiliar.WriteLine(auxiliar(i).KpVcmc)
            //   }




            for (i = 0; i <= K; i++) {
                // stAtual(i) = auxiliar(i)
            }

            quantidadeIteracoes += 1;
        }


        //  'ordena a estrutura 
        //   ordenacaoBubbleSortKpVcmc(stAtual)

        //  stMelhor = stAtual(0)

    }

    public double gaussian(double x, double peso, String gaussianaNomeVariavel, int indice) {
        double aux1, aux2;

        double desvioPadrao;

        double media;

        //double  pesoSolucao  = stAtual(indice).pesoW

        // media = somatorioTotalDaVariavel(gaussianaNomeVariavel)
        //  media = media / (K + 1)

        // desvioPadrao = calculaDesvioPadrao(x, gaussianaNomeVariavel)

        // aux1 = 1 / (desvioPadrao * Sqrt(2 * Math.PI));
        //  aux2 = ((x - media) ^ 2) / (2 * (desvioPadrao ^ 2))

        //  Gaussian = pesoSolucao * aux1 * Math.E ^ (-aux2)
        // Gaussian = x - (Gaussian * desvioPadrao)

        // Return Gaussian
        return 0;
    }

    private double somatorioTotalDaVariavel(String nomeVariavel) {

        double soma;

        /*
         Select Case nomeVariavel

         Case "Sh"
         For i As Integer = 0 To K
         soma += stAtual(i).Sh
         Next

         Case "Cm"
         For i As Integer = 0 To K
         soma += stAtual(i).Cm
         Next

         Case "Kft"
         For i As Integer = 0 To K
         soma += stAtual(i).Kft
         Next

         Case "Tft"
         For i As Integer = 0 To K
         soma += stAtual(i).Tft
         Next

         Case "Ctu"
         For i As Integer = 0 To K
         soma += stAtual(i).Ctu
         Next

         Case "Sm"
         For i As Integer = 0 To K
         soma += stAtual(i).Sm
         Next

         Case Else
         MessageBox.Show("Erro no parametro")

         End Select

         Return soma
         */
        return 0;
    }

    // ' Funções para gerar números Randomicos no intervalo ========='
    public double aleatorio(double n1, double n2) {
        //  Randomize()
        // 'gera um numero aleatorio entre [a, b] - b tem que ser maior que a
        //  Dim x As Double

        //  'x = (((b - a + 1) * Rnd) + a)
        //  x = Round((((b - a + 1) * Rnd()) + a), 4)
        //  While x < a Or x > b
        //     'até ter um numero aleatorio dentro do range
        //      'x = (((b - a + 1) * Rnd) + a)
        //      x = Round((((b - a + 1) * Rnd()) + a), 4)
        //  End While

        //  aleatorio = x

        return 0;
    }

    public double aleatorio_01() {
        /** IMPLEMENTAÇÃO EM JAVA */
        double aleatorio;
        Random random = new Random();
        aleatorio = random.nextDouble();
        return aleatorio;
        
        /** IMPLEMENTAÇÃO EM VB (CASO NECESSITE) */
        // Randomize()
        // 'gera numero aleatorio entre 0 e 1
        //  'Randomize
        //  'aleatorio_01 = Rnd
        //  ' aleatorio_01 = Round(Rnd, 4)
        //  Return VBMath.Rnd()
    }
}
